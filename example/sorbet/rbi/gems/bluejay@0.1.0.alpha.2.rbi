# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `bluejay` gem.
# Please instead update this file by running `bin/tapioca gem bluejay`.

# source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#4
module Bluejay
  private

  def parse(_arg0); end

  class << self
    def parse(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/base/custom_scalar_type.rb#5
module Bluejay::Base; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/custom_scalar_type.rb#6
module Bluejay::Base::CustomScalarType
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/custom_scalar_type.rb#13
  sig { abstract.returns(::Bluejay::CustomScalarTypeDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/directive.rb#6
module Bluejay::Base::Directive
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/directive.rb#22
  sig { abstract.returns(::Bluejay::DirectiveDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/directive.rb#10
module Bluejay::Base::Directive::Instance
  interface!

  mixes_in_class_methods ::Bluejay::Base::Directive
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/enum_type.rb#6
module Bluejay::Base::EnumType
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/enum_type.rb#13
  sig { abstract.returns(::Bluejay::EnumTypeDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/input_object_type.rb#6
module Bluejay::Base::InputObjectType
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/input_object_type.rb#13
  sig { abstract.returns(::Bluejay::InputObjectTypeDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/interface_type.rb#6
module Bluejay::Base::InterfaceType
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/interface_type.rb#13
  sig { abstract.returns(::Bluejay::InterfaceTypeDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/object_type.rb#6
module Bluejay::Base::ObjectType
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/object_type.rb#13
  sig { abstract.returns(::Bluejay::ObjectTypeDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/query_root.rb#6
module Bluejay::Base::QueryRoot
  requires_ancestor { Bluejay::Base::ObjectType }

  interface!
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/schema.rb#6
module Bluejay::Base::Schema
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/schema.rb#13
  sig { abstract.returns(::Bluejay::SchemaDefinition) }
  def definition; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/base/union_type.rb#6
module Bluejay::Base::UnionType
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/base/union_type.rb#13
  sig { abstract.returns(::Bluejay::UnionTypeDefinition) }
  def definition; end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/base_input_type.rb#5
Bluejay::BaseInputType = T.type_alias { T.any(::Bluejay::Base::CustomScalarType, ::Bluejay::Base::EnumType, ::Bluejay::Base::InputObjectType, ::Bluejay::Scalar) }

# source://bluejay//../../bluejay-rb/lib/bluejay/base_output_type.rb#5
Bluejay::BaseOutputType = T.type_alias { T.any(::Bluejay::Base::CustomScalarType, ::Bluejay::Base::EnumType, ::Bluejay::Base::InterfaceType, ::Bluejay::Base::ObjectType, ::Bluejay::Base::UnionType, ::Bluejay::Scalar) }

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin.rb#5
module Bluejay::Builtin
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin.rb#10
    sig { returns(::Bluejay::FieldDefinition) }
    def typename_field_definition; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/deprecated.rb#6
module Bluejay::Builtin::Directives; end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/deprecated.rb#7
class Bluejay::Builtin::Directives::Deprecated < ::Bluejay::Directive
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/deprecated.rb#17
    sig { override.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def argument_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/deprecated.rb#12
    sig { override.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/deprecated.rb#24
    sig { override.returns(T::Array[::Bluejay::DirectiveLocation]) }
    def locations; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/include.rb#7
class Bluejay::Builtin::Directives::Include < ::Bluejay::Directive
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/include.rb#17
    sig { override.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def argument_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/include.rb#12
    sig { override.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/include.rb#24
    sig { override.returns(T::Array[::Bluejay::DirectiveLocation]) }
    def locations; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/skip.rb#7
class Bluejay::Builtin::Directives::Skip < ::Bluejay::Directive
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/skip.rb#17
    sig { override.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def argument_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/skip.rb#12
    sig { override.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/skip.rb#24
    sig { override.returns(T::Array[::Bluejay::DirectiveLocation]) }
    def locations; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/specified_by.rb#7
class Bluejay::Builtin::Directives::SpecifiedBy < ::Bluejay::Directive
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/specified_by.rb#17
    sig { override.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def argument_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/specified_by.rb#12
    sig { override.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/directives/specified_by.rb#24
    sig { override.returns(T::Array[::Bluejay::DirectiveLocation]) }
    def locations; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/directive_location.rb#6
module Bluejay::Builtin::EnumTypes; end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/directive_location.rb#7
class Bluejay::Builtin::EnumTypes::DirectiveLocation < ::Bluejay::EnumType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/directive_location.rb#17
    sig { override.returns(T::Array[::Bluejay::EnumValueDefinition]) }
    def enum_value_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/directive_location.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/type_kind.rb#7
class Bluejay::Builtin::EnumTypes::TypeKind < ::Bluejay::EnumType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/type_kind.rb#17
    sig { override.returns(T::Array[::Bluejay::EnumValueDefinition]) }
    def enum_value_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/enum_types/type_kind.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/enum_value.rb#6
module Bluejay::Builtin::ObjectTypes; end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/directive.rb#7
class Bluejay::Builtin::ObjectTypes::Directive < ::Bluejay::ObjectType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/directive.rb#17
    sig { override.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/directive.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/enum_value.rb#7
class Bluejay::Builtin::ObjectTypes::EnumValue < ::Bluejay::ObjectType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/enum_value.rb#17
    sig { override.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/enum_value.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/field.rb#7
class Bluejay::Builtin::ObjectTypes::Field < ::Bluejay::ObjectType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/field.rb#17
    sig { override.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/field.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/input_value.rb#7
class Bluejay::Builtin::ObjectTypes::InputValue < ::Bluejay::ObjectType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/input_value.rb#17
    sig { override.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/input_value.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/schema.rb#7
class Bluejay::Builtin::ObjectTypes::Schema < ::Bluejay::ObjectType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/schema.rb#17
    sig { override.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/schema.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/type.rb#7
class Bluejay::Builtin::ObjectTypes::Type < ::Bluejay::ObjectType
  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/type.rb#17
    sig { override.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/builtin/object_types/type.rb#12
    sig { override.returns(::String) }
    def graphql_name; end
  end
end

class Bluejay::CoercionError
  def ==(_arg0); end
  def inspect; end
  def message; end
  def path; end

  class << self
    def new(_arg0, _arg1); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#5
class Bluejay::CustomScalarType
  extend T::Generic
  extend ::Bluejay::NameFromClass
  extend ::Bluejay::Base::CustomScalarType

  abstract!

  InternalRepresentation = type_template

  class << self
    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#44
    sig { abstract.params(value: T.untyped).returns(::Bluejay::Result) }
    def coerce_input(value); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#39
    sig { overridable.params(value: InternalRepresentation).returns(::Bluejay::Result) }
    def coerce_result(value); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#24
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#29
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#19
    sig { overridable.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#47
    sig { overridable.returns(::String) }
    def internal_representation_sorbet_type_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#34
    sig { overridable.returns(T.nilable(::String)) }
    def specified_by_url; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#54
    sig(:final) { override.returns(::Bluejay::CustomScalarTypeDefinition) }
    def definition; end
  end
end

class Bluejay::CustomScalarTypeDefinition
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::CustomScalarTypeDefinition::CoercionMethodSignature
  class << self
    def exception(_arg0); end
  end
end

Bluejay::CustomScalarTypeDefinition::CoercionMethodSignature::Result = T.let(T.unsafe(nil), Bluejay::CustomScalarTypeDefinition::CoercionMethodSignature)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#5
class Bluejay::Directive
  include ::Bluejay::Base::Directive::Instance
  extend ::Bluejay::Base::Directive
  extend ::Bluejay::InputTypeShorthands
  extend ::Bluejay::NameFromClass

  abstract!

  # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#58
  def initialize(**kwargs); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#66
  def ==(other); end

  class << self
    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#28
    sig { abstract.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def argument_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#23
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#18
    sig { overridable.returns(::String) }
    def graphql_name; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#31
    sig { abstract.returns(T::Array[::Bluejay::DirectiveLocation]) }
    def locations; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#34
    sig { overridable.returns(T::Boolean) }
    def repeatable?; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#41
    sig(:final) { override.returns(::Bluejay::DirectiveDefinition) }
    def definition; end
  end
end

class Bluejay::DirectiveDefinition
  def args; end
  def argument_definitions; end
  def description; end
  def locations; end
  def name; end
  def repeatable?; end
  def resolve_typename; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::DirectiveLocation; end
Bluejay::DirectiveLocation::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::ENUM = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::ENUM_VALUE = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::FIELD = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::FIELD_DEFINITION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::INLINE_FRAGMENT = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::INPUT_OBJECT = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::INTERFACE = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::MUTATION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::OBJECT = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::QUERY = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::SCALAR = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::SCHEMA = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::SUBSCRIPTION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::UNION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)
Bluejay::DirectiveLocation::VARIABLE_DEFINITION = T.let(T.unsafe(nil), Bluejay::DirectiveLocation)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#5
class Bluejay::EnumType
  extend ::Bluejay::NameFromClass
  extend ::Bluejay::Base::EnumType

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#20
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#28
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#25
    sig { abstract.returns(T::Array[::Bluejay::EnumValueDefinition]) }
    def enum_value_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#15
    sig { overridable.returns(::String) }
    def graphql_name; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#35
    sig(:final) { override.returns(::Bluejay::EnumTypeDefinition) }
    def definition; end
  end
end

class Bluejay::EnumTypeDefinition
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::EnumValueDefinition
  def deprecated?; end
  def deprecation_reason; end
  def description; end
  def name; end
  def resolve_typename; end

  class << self
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/errors.rb#5
module Bluejay::Errors; end

# source://bluejay//../../bluejay-rb/lib/bluejay/errors.rb#6
class Bluejay::Errors::BaseError < ::StandardError; end

# source://bluejay//../../bluejay-rb/lib/bluejay/errors.rb#8
class Bluejay::Errors::DefaultValueError < ::Bluejay::Errors::BaseError
  # source://bluejay//../../bluejay-rb/lib/bluejay/errors.rb#12
  sig { params(errors: T::Array[::Bluejay::CoercionError], value: ::Object).void }
  def initialize(errors, value); end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/errors.rb#18
class Bluejay::Errors::NonUniqueDefinitionNameError < ::Bluejay::Errors::BaseError; end

class Bluejay::ExecutionError
  def ==(_arg0); end
  def inspect; end
  def message; end
  def path; end

  class << self
    def new(*_arg0); end
  end
end

class Bluejay::ExecutionResult
  def errors; end
  def value; end
end

class Bluejay::FieldDefinition
  def args; end
  def argument_definitions; end
  def deprecated?; end
  def deprecation_reason; end
  def description; end
  def directives; end
  def name; end
  def resolve_typename; end
  def resolver_method_name; end
  def type; end

  class << self
    def new(_arg0); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#5
module Bluejay::Finalize
  abstract!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#12
  sig { abstract.void }
  def finalize; end

  # source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#15
  sig { params(obj: ::Bluejay::Finalize).void }
  def inherited(obj); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#5
class Bluejay::InputObjectType
  extend ::Bluejay::InputTypeShorthands
  extend ::Bluejay::NameFromClass
  extend ::Bluejay::Base::InputObjectType

  abstract!

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#57
  def initialize(**kwargs); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#65
  def ==(other); end

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#34
    sig { params(value: T.untyped, context: T.untyped).returns(::Bluejay::Result) }
    def coerce_input(value, context: T.unsafe(nil)); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#21
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#29
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#16
    sig { overridable.returns(::String) }
    def graphql_name; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#26
    sig { abstract.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def input_field_definitions; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_object_type.rb#41
    sig(:final) { override.returns(::Bluejay::InputObjectTypeDefinition) }
    def definition; end
  end
end

class Bluejay::InputObjectTypeDefinition
  def coerce_input(_arg0, _arg1); end
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_field_definitions; end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::InputType
  def base?; end
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def list?; end
  def name; end
  def of_type; end
  def possible_types; end
  def required?; end
  def resolve_typename; end
  def sorbet_type; end
  def specified_by_url; end
  def unwrap_list; end

  class << self
    def list(_arg0); end
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/input_type_shorthands.rb#5
module Bluejay::InputTypeShorthands
  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_shorthands.rb#9
  sig do
    params(
      t: T.any(::Bluejay::Base::CustomScalarType, ::Bluejay::Base::EnumType, ::Bluejay::Base::InputObjectType, ::Bluejay::Scalar)
    ).returns(::Bluejay::InputType)
  end
  def it(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_shorthands.rb#14
  sig do
    params(
      t: T.any(::Bluejay::Base::CustomScalarType, ::Bluejay::Base::EnumType, ::Bluejay::Base::InputObjectType, ::Bluejay::Scalar)
    ).returns(::Bluejay::InputType)
  end
  def it!(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_shorthands.rb#19
  sig { params(t: ::Bluejay::InputType).returns(::Bluejay::InputType) }
  def lit(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_shorthands.rb#24
  sig { params(t: ::Bluejay::InputType).returns(::Bluejay::InputType) }
  def lit!(t); end
end

class Bluejay::InputValueDefinition
  def default_value; end
  def description; end
  def name; end
  def resolve_typename; end
  def ruby_name; end
  def type; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::InterfaceImplementation
  def interface; end

  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#5
class Bluejay::InterfaceType
  extend ::Bluejay::OutputTypeShorthands
  extend ::Bluejay::InputTypeShorthands
  extend ::Bluejay::NameFromClass
  extend ::Bluejay::Base::InterfaceType

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#22
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#35
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#27
    sig { abstract.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#17
    sig { overridable.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#30
    sig { overridable.returns(T::Array[::Bluejay::InterfaceImplementation]) }
    def interface_implementations; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#42
    sig { params(name: ::Symbol).returns(T.untyped) }
    def const_missing(name); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#52
    sig { override.returns(::Bluejay::InterfaceTypeDefinition) }
    def definition; end
  end
end

class Bluejay::InterfaceTypeDefinition
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end

  class << self
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/json_value.rb#5
Bluejay::JsonValue = T.type_alias { T.nilable(T.any(::Float, ::Integer, ::String, T::Array[::Object], T::Boolean, T::Hash[::String, ::Object])) }

# source://bluejay//../../bluejay-rb/lib/bluejay/name_from_class.rb#5
module Bluejay::NameFromClass
  requires_ancestor { Module }

  private

  # source://bluejay//../../bluejay-rb/lib/bluejay/name_from_class.rb#14
  sig { returns(::String) }
  def name_from_class; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#5
class Bluejay::ObjectType
  extend ::Bluejay::OutputTypeShorthands
  extend ::Bluejay::InputTypeShorthands
  extend ::Bluejay::NameFromClass
  extend ::Bluejay::Base::ObjectType

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#22
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#35
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#27
    sig { abstract.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#17
    sig { overridable.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#30
    sig { overridable.returns(T::Array[::Bluejay::InterfaceImplementation]) }
    def interface_implementations; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#42
    sig { params(name: ::Symbol).returns(T.untyped) }
    def const_missing(name); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#52
    sig { override.returns(::Bluejay::ObjectTypeDefinition) }
    def definition; end
  end
end

class Bluejay::ObjectTypeDefinition
  def description; end
  def enum_values(_arg0); end
  def field_definitions; end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::OutputType
  def base?; end
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def list?; end
  def name; end
  def of_type; end
  def possible_types; end
  def required?; end
  def resolve_typename; end
  def sorbet_type; end
  def specified_by_url; end
  def unwrap_list; end

  class << self
    def list(_arg0); end
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/output_type_shorthands.rb#5
module Bluejay::OutputTypeShorthands
  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_shorthands.rb#19
  sig { params(t: ::Bluejay::OutputType).returns(::Bluejay::OutputType) }
  def lot(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_shorthands.rb#24
  sig { params(t: ::Bluejay::OutputType).returns(::Bluejay::OutputType) }
  def lot!(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_shorthands.rb#9
  sig do
    params(
      t: T.any(::Bluejay::Base::CustomScalarType, ::Bluejay::Base::EnumType, ::Bluejay::Base::InterfaceType, ::Bluejay::Base::ObjectType, ::Bluejay::Base::UnionType, ::Bluejay::Scalar)
    ).returns(::Bluejay::OutputType)
  end
  def ot(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_shorthands.rb#14
  sig do
    params(
      t: T.any(::Bluejay::Base::CustomScalarType, ::Bluejay::Base::EnumType, ::Bluejay::Base::InterfaceType, ::Bluejay::Base::ObjectType, ::Bluejay::Base::UnionType, ::Bluejay::Scalar)
    ).returns(::Bluejay::OutputType)
  end
  def ot!(t); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/query_root.rb#5
class Bluejay::QueryRoot < ::Bluejay::ObjectType
  extend ::Bluejay::Base::QueryRoot

  abstract!

  class << self
    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/query_root.rb#16
    sig { override.returns(::Bluejay::ObjectTypeDefinition) }
    def definition; end
  end
end

class Bluejay::Result
  def ==(_arg0); end
  def err?; end
  def inspect; end
  def ok?; end
  def unwrap; end
  def unwrap_err; end

  class << self
    def [](_arg0, _arg1); end
    def err(_arg0); end
    def ok(_arg0); end
  end
end

class Bluejay::Scalar
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end
end

Bluejay::Scalar::Boolean = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::Float = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::ID = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::Int = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::String = T.let(T.unsafe(nil), Bluejay::Scalar)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#5
class Bluejay::Schema
  extend ::Bluejay::Finalize
  extend ::Bluejay::Base::Schema

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#15
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#28
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#41
    sig do
      params(
        query: ::String,
        initial_value: ::Object,
        operation_name: T.nilable(::String),
        variables: T::Hash[::String, T.untyped],
        context: T.untyped
      ).returns(::Bluejay::ExecutionResult)
    end
    def execute(query:, initial_value:, operation_name: T.unsafe(nil), variables: T.unsafe(nil), context: T.unsafe(nil)); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#23
    sig { overridable.returns(T.nilable(T.class_of(Bluejay::ObjectType))) }
    def mutation; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#20
    sig { abstract.returns(T.class_of(Bluejay::QueryRoot)) }
    def query; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#51
    sig { params(context: T.untyped).returns(::String) }
    def to_definition(context: T.unsafe(nil)); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#46
    sig { params(query: ::String, context: T.untyped).returns(T::Array[::Bluejay::ValidationError]) }
    def validate_query(query:, context: T.unsafe(nil)); end

    protected

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#58
    sig(:final) { override.void }
    def finalize; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#65
    sig { params(name: ::Symbol).returns(T.untyped) }
    def const_missing(name); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#75
    sig { override.returns(::Bluejay::SchemaDefinition) }
    def definition; end
  end
end

class Bluejay::SchemaDefinition
  def description; end
  def directives; end
  def execute(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def mutation_type; end
  def query_type; end
  def resolve_typename; end
  def subscription_type; end
  def to_definition(_arg0); end
  def type(_arg0); end
  def types; end
  def validate_query(_arg0, _arg1); end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::UnionMemberType
  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#5
class Bluejay::UnionType
  extend ::Bluejay::NameFromClass
  extend ::Bluejay::Base::UnionType

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#20
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#28
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#15
    sig { overridable.returns(::String) }
    def graphql_name; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#25
    sig { abstract.returns(T::Array[::Bluejay::UnionMemberType]) }
    def member_types; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#35
    sig { override.returns(::Bluejay::UnionTypeDefinition) }
    def definition; end
  end
end

class Bluejay::UnionTypeDefinition
  def description; end
  def enum_values(_arg0); end
  def fields(_arg0); end
  def input_fields; end
  def interfaces; end
  def kind; end
  def name; end
  def of_type; end
  def possible_types; end
  def resolve_typename; end
  def specified_by_url; end

  class << self
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/version.rb#4
Bluejay::VERSION = T.let(T.unsafe(nil), String)

class Bluejay::ValidationError
  def ==(_arg0); end
  def inspect; end
  def message; end

  class << self
    def new(_arg0); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/visibility.rb#5
module Bluejay::Visibility
  interface!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/visibility.rb#12
  sig { abstract.returns(::String) }
  def cache_key; end

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/visibility.rb#15
  sig { abstract.params(context: T.untyped).returns(T::Boolean) }
  def visible?(context); end
end
