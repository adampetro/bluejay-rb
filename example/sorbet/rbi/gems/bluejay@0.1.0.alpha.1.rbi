# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `bluejay` gem.
# Please instead update this file by running `bin/tapioca gem bluejay`.

# source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#4
module Bluejay
  private

  def parse(_arg0); end

  class << self
    def parse(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/base_input_type_reference.rb#5
Bluejay::BaseInputTypeReference = T.type_alias { T.any(::Bluejay::Scalar, T.class_of(Bluejay::CustomScalarType), T.class_of(Bluejay::EnumType), T.class_of(Bluejay::InputType)) }

# source://bluejay//../../bluejay-rb/lib/bluejay/base_output_type_reference.rb#5
Bluejay::BaseOutputTypeReference = T.type_alias { T.any(::Bluejay::Scalar, T.class_of(Bluejay::CustomScalarType), T.class_of(Bluejay::EnumType), T.class_of(Bluejay::InterfaceType), T.class_of(Bluejay::ObjectType), T.class_of(Bluejay::UnionType)) }

class Bluejay::CoercionError
  def ==(_arg0); end
  def inspect; end
  def message; end
  def path; end

  class << self
    def new(_arg0, _arg1); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#5
class Bluejay::CustomScalarType
  extend ::Bluejay::NameFromClass

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#19
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#24
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#14
    sig { overridable.returns(::String) }
    def graphql_name; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/custom_scalar_type.rb#31
    sig(:final) { returns(::Bluejay::CustomScalarTypeDefinition) }
    def definition; end
  end
end

class Bluejay::CustomScalarTypeDefinition
  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#5
class Bluejay::Directive
  extend ::Bluejay::InputTypeReferenceShorthands
  extend ::Bluejay::NameFromClass

  abstract!

  # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#51
  def initialize(*args); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#58
  def ==(other); end

  class << self
    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#25
    sig { abstract.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def argument_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#20
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#15
    sig { overridable.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#28
    sig { overridable.returns(T::Boolean) }
    def repeatable?; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/directive.rb#35
    sig(:final) { returns(::Bluejay::DirectiveDefinition) }
    def definition; end
  end
end

class Bluejay::DirectiveDefinition
  def argument_definitions; end

  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#5
class Bluejay::EnumType
  extend ::Bluejay::Finalize
  extend ::Bluejay::NameFromClass

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#21
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#29
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#26
    sig { abstract.returns(T::Array[::Bluejay::EnumValueDefinition]) }
    def enum_value_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#16
    sig { overridable.returns(::String) }
    def graphql_name; end

    protected

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#36
    sig(:final) { override.void }
    def finalize; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/enum_type.rb#43
    sig(:final) { returns(::Bluejay::EnumTypeDefinition) }
    def definition; end
  end
end

class Bluejay::EnumTypeDefinition
  class << self
    def new(_arg0); end
  end
end

class Bluejay::EnumValueDefinition
  def name; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::ExecutionError
  def ==(_arg0); end
  def inspect; end
  def message; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::ExecutionResult
  def errors; end
  def value; end
end

class Bluejay::FieldDefinition
  def argument_definitions; end
  def directives; end
  def name; end
  def resolver_method_name; end
  def type; end

  class << self
    def new(_arg0); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#5
module Bluejay::Finalize
  abstract!

  # @abstract
  #
  # source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#12
  sig { abstract.void }
  def finalize; end

  # source://bluejay//../../bluejay-rb/lib/bluejay/finalize.rb#15
  sig { params(obj: ::Bluejay::Finalize).void }
  def inherited(obj); end
end

class Bluejay::InputObjectTypeDefinition
  def coerce_input(_arg0); end
  def input_field_definitions; end

  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#5
class Bluejay::InputType
  extend ::Bluejay::InputTypeReferenceShorthands
  extend ::Bluejay::NameFromClass

  abstract!

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#58
  def initialize(*args); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#65
  def ==(other); end

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#35
    sig { params(value: T.untyped).returns(::Bluejay::Result) }
    def coerce_input(value); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#22
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#30
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#17
    sig { overridable.returns(::String) }
    def graphql_name; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#27
    sig { abstract.returns(T::Array[::Bluejay::InputValueDefinition]) }
    def input_field_definitions; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/input_type.rb#42
    sig(:final) { returns(::Bluejay::InputObjectTypeDefinition) }
    def definition; end
  end
end

class Bluejay::InputTypeReference
  def base?; end
  def list?; end
  def required?; end
  def sorbet_type; end
  def unwrap_list; end

  class << self
    def list(_arg0); end
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/input_type_reference_shorthands.rb#5
module Bluejay::InputTypeReferenceShorthands
  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_reference_shorthands.rb#9
  sig do
    params(
      t: T.any(::Bluejay::Scalar, T.class_of(Bluejay::CustomScalarType), T.class_of(Bluejay::EnumType), T.class_of(Bluejay::InputType))
    ).returns(::Bluejay::InputTypeReference)
  end
  def it(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_reference_shorthands.rb#14
  sig do
    params(
      t: T.any(::Bluejay::Scalar, T.class_of(Bluejay::CustomScalarType), T.class_of(Bluejay::EnumType), T.class_of(Bluejay::InputType))
    ).returns(::Bluejay::InputTypeReference)
  end
  def it!(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_reference_shorthands.rb#19
  sig { params(t: ::Bluejay::InputTypeReference).returns(::Bluejay::InputTypeReference) }
  def lit(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/input_type_reference_shorthands.rb#24
  sig { params(t: ::Bluejay::InputTypeReference).returns(::Bluejay::InputTypeReference) }
  def lit!(t); end
end

class Bluejay::InputValueDefinition
  def name; end
  def ruby_name; end
  def type; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::InterfaceImplementation
  def interface; end

  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#5
class Bluejay::InterfaceType
  extend ::Bluejay::OutputTypeReferenceShorthands
  extend ::Bluejay::InputTypeReferenceShorthands
  extend ::Bluejay::NameFromClass

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#21
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#34
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#26
    sig { abstract.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#16
    sig { overridable.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#29
    sig { overridable.returns(T::Array[::Bluejay::InterfaceImplementation]) }
    def interface_implementations; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#41
    sig { params(name: ::Symbol).returns(T.untyped) }
    def const_missing(name); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/interface_type.rb#51
    sig { returns(::Bluejay::InterfaceTypeDefinition) }
    def definition; end
  end
end

class Bluejay::InterfaceTypeDefinition
  class << self
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/json_value.rb#5
Bluejay::JsonValue = T.type_alias { T.nilable(T.any(::Float, ::Integer, ::String, T::Array[::Object], T::Boolean, T::Hash[::String, ::Object])) }

# source://bluejay//../../bluejay-rb/lib/bluejay/name_from_class.rb#5
module Bluejay::NameFromClass
  requires_ancestor { Class }

  private

  # source://bluejay//../../bluejay-rb/lib/bluejay/name_from_class.rb#14
  sig { returns(::String) }
  def name_from_class; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#5
class Bluejay::ObjectType
  extend ::Bluejay::OutputTypeReferenceShorthands
  extend ::Bluejay::InputTypeReferenceShorthands
  extend ::Bluejay::NameFromClass

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#21
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#34
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#26
    sig { abstract.returns(T::Array[::Bluejay::FieldDefinition]) }
    def field_definitions; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#16
    sig { overridable.returns(::String) }
    def graphql_name; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#29
    sig { overridable.returns(T::Array[::Bluejay::InterfaceImplementation]) }
    def interface_implementations; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#41
    sig { params(name: ::Symbol).returns(T.untyped) }
    def const_missing(name); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/object_type.rb#51
    sig { returns(::Bluejay::ObjectTypeDefinition) }
    def definition; end
  end
end

class Bluejay::ObjectTypeDefinition
  def field_definitions; end
  def name; end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::OutputTypeReference
  def base?; end
  def list?; end
  def required?; end
  def sorbet_type; end
  def unwrap_list; end

  class << self
    def list(_arg0); end
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/output_type_reference_shorthands.rb#5
module Bluejay::OutputTypeReferenceShorthands
  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_reference_shorthands.rb#19
  sig { params(t: ::Bluejay::OutputTypeReference).returns(::Bluejay::OutputTypeReference) }
  def lot(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_reference_shorthands.rb#24
  sig { params(t: ::Bluejay::OutputTypeReference).returns(::Bluejay::OutputTypeReference) }
  def lot!(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_reference_shorthands.rb#9
  sig do
    params(
      t: T.any(::Bluejay::Scalar, T.class_of(Bluejay::CustomScalarType), T.class_of(Bluejay::EnumType), T.class_of(Bluejay::InterfaceType), T.class_of(Bluejay::ObjectType), T.class_of(Bluejay::UnionType))
    ).returns(::Bluejay::OutputTypeReference)
  end
  def ot(t); end

  # source://bluejay//../../bluejay-rb/lib/bluejay/output_type_reference_shorthands.rb#14
  sig do
    params(
      t: T.any(::Bluejay::Scalar, T.class_of(Bluejay::CustomScalarType), T.class_of(Bluejay::EnumType), T.class_of(Bluejay::InterfaceType), T.class_of(Bluejay::ObjectType), T.class_of(Bluejay::UnionType))
    ).returns(::Bluejay::OutputTypeReference)
  end
  def ot!(t); end
end

class Bluejay::Result
  def err?; end
  def inspect; end
  def ok?; end
  def unwrap; end
  def unwrap_err; end

  class << self
    def [](_arg0, _arg1); end
  end
end

class Bluejay::Scalar; end
Bluejay::Scalar::Boolean = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::Float = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::ID = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::Int = T.let(T.unsafe(nil), Bluejay::Scalar)
Bluejay::Scalar::String = T.let(T.unsafe(nil), Bluejay::Scalar)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#5
class Bluejay::Schema
  extend ::Bluejay::Finalize

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#15
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#28
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#40
    sig do
      params(
        query: ::String,
        operation_name: T.nilable(::String),
        initial_value: ::Object,
        variables: T::Hash[::String, T.untyped]
      ).returns(::Bluejay::ExecutionResult)
    end
    def execute(query:, operation_name:, initial_value:, variables: T.unsafe(nil)); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#23
    sig { overridable.returns(T.nilable(T.class_of(Bluejay::ObjectType))) }
    def mutation; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#20
    sig { abstract.returns(T.class_of(Bluejay::ObjectType)) }
    def query; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#45
    sig { params(query: ::String).returns(T::Array[::Bluejay::ValidationError]) }
    def validate_query(query:); end

    protected

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#52
    sig(:final) { override.void }
    def finalize; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#59
    sig { params(name: ::Symbol).returns(T.untyped) }
    def const_missing(name); end

    # source://bluejay//../../bluejay-rb/lib/bluejay/schema.rb#69
    sig { returns(::Bluejay::SchemaDefinition) }
    def definition; end
  end
end

class Bluejay::SchemaDefinition
  def execute(_arg0, _arg1, _arg2, _arg3); end
  def validate_query(_arg0); end

  class << self
    def new(_arg0); end
  end
end

class Bluejay::UnionMemberType
  class << self
    def new(_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#5
class Bluejay::UnionType
  extend ::Bluejay::NameFromClass

  abstract!

  class << self
    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#19
    sig { overridable.returns(T.nilable(::String)) }
    def description; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#27
    sig { overridable.returns(T::Array[::Bluejay::Directive]) }
    def directives; end

    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#14
    sig { overridable.returns(::String) }
    def graphql_name; end

    # @abstract
    #
    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#24
    sig { abstract.returns(T::Array[::Bluejay::UnionMemberType]) }
    def member_types; end

    private

    # source://bluejay//../../bluejay-rb/lib/bluejay/union_type.rb#34
    sig { returns(::Bluejay::UnionTypeDefinition) }
    def definition; end
  end
end

class Bluejay::UnionTypeDefinition
  class << self
    def new(_arg0); end
  end
end

# source://bluejay//../../bluejay-rb/lib/bluejay/version.rb#4
Bluejay::VERSION = T.let(T.unsafe(nil), String)

class Bluejay::ValidationError
  def ==(_arg0); end
  def inspect; end
  def message; end

  class << self
    def new(_arg0); end
  end
end
